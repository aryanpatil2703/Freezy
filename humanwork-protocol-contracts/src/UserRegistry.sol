// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

// Interface to interact with the official World ID smart contract.
// This defines the function we need to call to verify a user's proof.
interface IWorldID {
    function verifyProof(
        uint256 root,
        uint256 groupId,
        uint256 signalHash,
        uint256 nullifierHash,
        uint256 externalNullifierHash,
        uint256[8] calldata proof
    ) external view;
}

/**
 * @title UserRegistry
 * @dev Manages user profiles, gated by World ID verification. It stores user data
 * as IPFS Content Identifiers (CIDs) which will be generated by Lighthouse.
 */
contract UserRegistry {
    // The address of the World ID contract. This will be different for World Chain and Hedera.
    IWorldID internal immutable worldId;

    // Struct to hold all the data for a registered user.
    struct User {
        address wallet;
        string profileCID;      // Lighthouse IPFS hash for the user's public profile JSON.
        string credentialsCID;  // Lighthouse IPFS hash for their private credentials JSON.
        string githubProofCID;  // Lighthouse IPFS hash for the verifiable GitHub proof.
        bool isVerified;        // This will be true if their World ID proof was valid.
        uint256 registrationTime;
        uint256 chainId;         // Records which chain the user registered on.
    }

    // --- MAPPINGS ---
    // Mapping from a user's wallet address to their User data.
    mapping(address => User) public users;
    // Mapping to store used nullifier hashes to prevent the same World ID proof from being used twice.
    mapping(uint256 => bool) public nullifierHashes;
    // A simple mapping to quickly check if a wallet address is already registered.
    mapping(address => bool) public isRegistered;

    // --- EVENTS ---
    event UserRegistered(address indexed user, string profileCID, uint256 chainId);
    event GitHubProofAdded(address indexed user, string githubProofCID);

    /**
     * @dev The constructor is called once when the contract is deployed.
     * @param _worldId The address of the World ID contract on the specific deployment chain.
     */
    constructor(address _worldId) {
        worldId = IWorldID(_worldId);
    }

    /**
     * @notice Registers a new user after successfully verifying their World ID proof.
     * @param _profileCID The IPFS CID for the user's public profile, from Lighthouse.
     * @param _credentialsCID The IPFS CID for the user's private credentials, from Lighthouse.
     * @param root The Merkle tree root from the World ID proof.
     * @param nullifierHash A unique hash that proves the user hasn't registered before.
     * @param proof The zero-knowledge proof generated by the user's World ID.
     */
    function registerUser(
        string memory _profileCID,
        string memory _credentialsCID,
        uint256 root,
        uint256 nullifierHash,
        uint256[8] calldata proof
    ) external {
        require(!isRegistered[msg.sender], "User is already registered.");
        require(!nullifierHashes[nullifierHash], "This World ID has already been used.");

        // The "signal" is a piece of public data you want to link the proof to. Here, it's the user's wallet address.
        uint256 signalHash = uint256(keccak256(abi.encodePacked(msg.sender)));
        
        // The "externalNullifier" is a unique identifier for your app to prevent replay attacks across different apps.
        uint256 externalNullifierHash = uint256(keccak256(abi.encodePacked("humanwork-protocol")));

        // Call the World ID contract to verify the proof. This will revert if the proof is invalid.
        worldId.verifyProof(
            root,
            1, // Group ID 1 is for Orb-verified users, the highest level of verification.
            signalHash,
            nullifierHash,
            externalNullifierHash,
            proof
        );

        // Mark the nullifier as used so this proof can't be submitted again.
        nullifierHashes[nullifierHash] = true;

        // If verification was successful, create and store the new user's profile.
        users[msg.sender] = User({
            wallet: msg.sender,
            profileCID: _profileCID,
            credentialsCID: _credentialsCID,
            githubProofCID: "", // This is added in a separate step.
            isVerified: true,
            registrationTime: block.timestamp,
            chainId: block.chainid
        });

        isRegistered[msg.sender] = true;
        emit UserRegistered(msg.sender, _profileCID, block.chainid);
    }

    /**
     * @notice Allows a registered user to add a verifiable GitHub proof to their profile.
     * @param _githubProofCID The Lighthouse IPFS CID of the generated proof.
     */
    function addGitHubProof(string memory _githubProofCID) external {
        require(isRegistered[msg.sender], "User is not registered.");
        users[msg.sender].githubProofCID = _githubProofCID;
        emit GitHubProofAdded(msg.sender, _githubProofCID);
    }
}